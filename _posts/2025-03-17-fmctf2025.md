---
title: '[WriteUp] FMCTF2025å¯†ç é¢˜è§£'
date: 2025-03-10
permalink: /posts/2025/03/fmctf2025/
excerpt: 'å¯¹èŒæ–°æŒºå‹å¥½çš„ä¸€åœºæ¯”èµ›, æŠ½æ—¶é—´åˆ·äº†ä¸€ä¸‹...'
tags:
  - CTF
  - ç½‘ç»œå®‰å…¨
  - å¯†ç å­¦
  - éå¯¹ç§°åŠ å¯†
  - rsa
---

# ç›®å½•

- [brutalrsa](#brutalrsa)
- [circular_maze](#circular_maze)
- [ez_rsa](#ez_rsa)
- [ezxor](#ezxor)
- [robin_s_mystery](#robin_s_mystery)
- [seal_the_deal](#seal_the_deal)
- [superguesser](#superguesser)
- [superguesser_v2](#superguesser_v2)
- [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)

## é¢˜ç›®

```
c =  41371441628678749855341069318913940139183366190092850457791401944637484881722387130432528789403867120983310612023037050412981687401539375118177921234958241549652642148049464476777138721957300380163011255302922062871368980358844918698066643476906429304993326666393192819367202508911333287188748033044647
e =  3
n =  125533848452137763185016834412259349043987425043688722410453579918645013940088212764269073831951730407180201649381111989694930753816422349270797992511026080967667823475550286796327579680655909172631694714891168782703472181155691095137469432249992072921349964218538827606766136606019411932023475455088911
```

## åˆ†æ

`e`å¾ˆå°, æ¨¡nå¾ˆå¤§, ç†è®ºä¸Šå¯ä»¥ç›´æ¥å¼€æ ¹æ±‚è§£.

## EXP

```python
from Crypto.Util.number import *
from gmpy2 import iroot

c =  41371441628678749855341069318913940139183366190092850457791401944637484881722387130432528789403867120983310612023037050412981687401539375118177921234958241549652642148049464476777138721957300380163011255302922062871368980358844918698066643476906429304993326666393192819367202508911333287188748033044647
e =  3
n =  125533848452137763185016834412259349043987425043688722410453579918645013940088212764269073831951730407180201649381111989694930753816422349270797992511026080967667823475550286796327579680655909172631694714891168782703472181155691095137469432249992072921349964218538827606766136606019411932023475455088911

k = 0
while 1:
    #c+k*n å¼€3æ¬¡æ–¹
    res = iroot(c+k*n,e)
    if(res[1] == True):
        print(b'FMCTF'+long_to_bytes(res[0])+b'}') #è½¬ä¸ºå­—ç¬¦ä¸²
        break
    k=k+1

#b'FMCTFBru7ef0rce_1s_s0me71mes_4n_effective_W4y!!!}'
```

# circular_maze

## é¢˜ç›®

```python
flag = "FMCTF{REDACTED}"


def enc(data : str):
    result = []
    for i in range(len(data)):
        result.append(
                    (
                        (
                            ord(data[i - 1]) +
                            ord(data[i]) + 
                        ord(data[(i + 1) % len(data)])
                     ) % 256)
                        .to_bytes() 
                )
                
    return b''.join(result)
print(enc(flag))
open("./flag.enc", "wb").write(enc(flag))
```

## åˆ†æ

ä¸»è¦å®ç°å¯¹æ¯ä¸€ä½å­—ç¬¦çš„å‰åä¸¤ä½è¿›è¡ŒåŠ å’Œåå–æ¨¡, æœ¬è´¨ä¸Šåªéœ€è¦è·å–å…¶ä¸­ä¸¤ä½å°±å¯ä»¥è·å–å‰©ä½™çš„å­—ç¬¦, éš¾ç‚¹ä¸»è¦å¯èƒ½æ˜¯å®ç°ç®—æ³•äº†.

## EXP

```python
flag = "FMCTF{REDACTED}"
mess = open("./flag.enc", "rb").read()

flag_1 = ord(flag[0])
flag_2 = ord(flag[1])
flag_3 = ord(flag[2])
return_flag = 'FM'
n = 3
i = 1
for _ in range(16):
    for j in range(65, 126):
        if mess[i] == (flag_1 + flag_2 + j) % 256:
            return_flag += chr(j)
            flag_1 = flag_2
            flag_2 = j
            i += 1
print(return_flag)

# FMCTF{broken_circle_is_not_fun_at_all}
```

# ez_rsa

## é¢˜ç›®

```python
from Crypto.Util.number import getPrime
import os

flag = os.getenv("FLAG", "FMCTF{F4K3_FL49}")
m = int(flag.encode().hex(), 16)

p = getPrime(512)
q = getPrime(512)

n = p*q
e = 65537
c = pow(m, e, n)

hint = p+q

print(f"{hint = }")
print(f"{n = }")
print(f"{c = }")

# hint = 17469292153344571442220879753705314094982989674618803961044325274734902918518047825543639089360378046111761829828690097867206972174713085299385569035446604
# n = 72178676992512160441554160179592383158203955928083976740488546189244761660478121450369459709272987174826935459768807973546852656122370605905453926547673003297830819475396600384101353650933279529161854454268770358323854195264696322371766082303954604264551309576730976571309522883511488619775495703381232031179
# c = 58920849369961001974878540043377399205173235403895163231084588694712964281923344842680972991777380071418111292770515352012869237864259800540355713208626735820573601770413846338478651482053989341163751620131823006414875347921150338651475973491744075397194132475674270761198474531891598902225518350430719735601
```

## åˆ†æ

ç»å…¸æ•°å­¦é—®é¢˜, å·²çŸ¥:

$$
\left\{\begin{matrix}
p*q=n \\
p+q=hint
\end{matrix}\right.
$$

å¯ä»¥è®¾pè¡¨è¾¾q, ç„¶åè§£æ–¹ç¨‹.

## EXP

```python
from sage.all import *
from Crypto.Util.number import *

e = 65537
hint = 17469292153344571442220879753705314094982989674618803961044325274734902918518047825543639089360378046111761829828690097867206972174713085299385569035446604
n = 72178676992512160441554160179592383158203955928083976740488546189244761660478121450369459709272987174826935459768807973546852656122370605905453926547673003297830819475396600384101353650933279529161854454268770358323854195264696322371766082303954604264551309576730976571309522883511488619775495703381232031179
c = 58920849369961001974878540043377399205173235403895163231084588694712964281923344842680972991777380071418111292770515352012869237864259800540355713208626735820573601770413846338478651482053989341163751620131823006414875347921150338651475973491744075397194132475674270761198474531891598902225518350430719735601

p_ = var('p_')
approx_p = int((p_*(hint - p_) - n).roots()[0][0])
p = int(approx_p)
q = n//p
d = pow(e, -1, (p-1)*(q-1))
print(long_to_bytes(pow(c, d, n)))

# b'FMCTF{rSA_34SY_P34SY_L3M0N_5QU33ZY}'
```

# ezxor

## é¢˜ç›®

```python
from pwn import *
FLAG = os.environ.get("FLAG", "FMCTF{F4K3_FL49}").encode()
key = os.urandom(7)
encryptedFlag = xor(FLAG, key).hex()
print(f"encryptedFlag = {encryptedFlag}")
# encryptedFlag = a850d725cb56b0de4fcb40de72a4df56a72ec06cafa75ecb41f51c95
```

## åˆ†æ

keyæ˜¯éšæœºç”Ÿæˆçš„7ä½å­—ç¬¦, ä½†æ˜¯å·²çŸ¥flagå¤´æœ‰"FMCTF{}", å¯ä»¥åå‘æ±‚è§£å‡ºkey, ç„¶åè§£å¯†.

## EXP

```python
from pwn import xor

# ç»™å®šçš„åŠ å¯†åçš„åå…­è¿›åˆ¶å­—ç¬¦ä¸²
encrypted_flag_hex = "a850d725cb56b0de4fcb40de72a4df56a72ec06cafa75ecb41f51c95"
encrypted_flag = bytes.fromhex(encrypted_flag_hex)

known_prefix = b"FMCTF{"

key = []
for i in range(6):
    key_byte = encrypted_flag[i] ^ known_prefix[i]
    key.append(key_byte)

last_index = len(encrypted_flag) - 1
key_byte_6 = encrypted_flag[last_index] ^ 0x7D  # 0x7Dæ˜¯'}'
key.append(key_byte_6)

full_key = bytes(key)
decrypted = xor(encrypted_flag, full_key)

print(decrypted)

# b'FMCTF{X0R_1S_L1K3_MAGIC_0x1}'
```

# robin_s_mystery

## é¢˜ç›®

```python
import random
from Crypto.PublicKey import RSA
from Crypto.Util.number import *

def nextPrime(prim):
    if isPrime(prim):
        return prim
    else:
        return nextPrime(prim+1)

p = getPrime(512)
q = nextPrime(p+1)
while p%4 != 3 or q%4 !=3:
    p = getPrime(512)
    q = nextPrime(p+1)

n = p*q
m = bytes_to_long( open('flag.txt','rb').read() )

c = pow(m, e, n)

rsa = RSA.construct((n, e))
print(rsa.exportKey().decode())
print(f"cipher: { long_to_bytes(c) }")

'''
-----BEGIN PUBLIC KEY-----
MIGcMA0GCSqGSIb3DQEBAQUAA4GKADCBhgKBgGjpRi/Hr5oN5NS219dZrq6nW7AC
Y7fUItXAvbgy0TtagVKO2goQiOssL331b7zRjMvdHkEBR4bTd+hHblmynO+2//fz
4DmVgdgMnrP54+2RSzguEGS1ONX4MpJonBsEGGc1IOiKECiwIbl4DkyTxl6AnFsz
ZI2E+lLDZnX5P44FAgEQ
-----END PUBLIC KEY-----
cipher: b'\x10\xc4\xbf\xfapg\xee\x00\xe4\xcd\x00\xb4i\xf5\x801\xdd\xafm\xb1\xad\x8dy\x01\xaa\x14\xd1\xa3\x14[\xdf\xc8c\xb1\xf4\xcb\xcf\xf0\xf9\x83\x85%\x19\xd2d>N\x9aR\xa4\xba\xc9\xda\xd8\xe4\xa2\x9cg%.\xac\xd7\xb5\x95\x7f\x87\x04?\xf7\xe4\x06(\xe7l\x1c"c\x95\x90z\xd4\x8b\x9f\x1b\x00\xc67\xe4\x82g\xc4b\x10\x8c\xe7s[\x95-TB+Z;\xe4\x00\x11<\xc51K\xec\x94ZL\xb2\xf9\x7fp<\xe6C\xf8\x7f\x90\x0bG\xcf'
'''
```

## åˆ†æ

è¿™é¢˜æ¶‰åŠäº†åŸºæœ¬çš„å¯¹rsaçš„pemæ–‡ä»¶ä½¿ç”¨, å¯ä»¥ä½¿ç”¨Cryptoåº“è‡ªå¸¦çš„è§£æå·¥å…·ç›´æ¥è·å–n, eå‚æ•°, ç„¶åæ‰¾åˆ°p, qç›¸è¿‘, å¯ä»¥ç›´æ¥å¼€æ ¹å»æ‰¾ç›¸é‚»ç´ æ•°, å¯†ç æ‰‹å¿«ä¹é¢˜äº†. æ‹¿åˆ°ç»“æœåå®é™…ä¸Šæ˜¯æ— æ³•ç›´æ¥æ±‚å‡ºç§é’¥çš„, å› ä¸ºå­˜åœ¨ä»¥ä¸‹ä¿¡æ¯:

```python
p = getPrime(512)
q = nextPrime(p+1)
while p%4 != 3 or q%4 !=3:
    p = getPrime(512)
    q = nextPrime(p+1)
```

p, qå‡æ»¡è¶³æ¨¡4äº3, åœ¨è·å–eçš„æ—¶å€™ä¼šå‘ç°èƒ½è¢«4æ•´é™¤, åœ¨æ±‚phiæ—¶p-1, q-1ä¹Ÿå‡èƒ½å¤Ÿè¢«4æ•´é™¤, eä¸phiä¸äº’ç´ , æ— æ³•ç›´æ¥ä½¿ç”¨å…¶ä¸­ä¸€ä¸ªç´ æ•°å–phiæ±‚è§£, ä¹Ÿå°±æ˜¯è¯´å­˜åœ¨ä»¥ä¸‹æƒ…å†µ:

$$
\begin{matrix}
gcd(e, (q-1)) = 4 \\
gcd(e, (p-1)) = 4
\end{matrix}
$$

è¿™é‡Œéœ€è¦ä½¿ç”¨ä¸­å›½å‰©ä½™å®šç†ç›´æ¥å–å‡ºflag, å¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•è·å–pä¸qçš„æ ¹:

```python
def find_res(gen):
    R = PolynomialRing(Zmod(gen), 'x')
    x = R.gen()
    f = x ** e - c
    f = f.monic()
    res = f.roots()
    return res
```

å‡½æ•°æ±‚è§£çš„resæ˜¯å¤šé¡¹å¼$$f=x^e-c$$åœ¨æ¨¡gen(å³åˆ†åˆ«æ˜¯pä¸q)æ„ä¹‰ä¸‹çš„æ ¹, å…¶ä¸­cæ˜¯å¯†æ–‡æ•°æ®, $$x^e\mod{gen}$$ä¸­çš„xä¸ºæ¨¡genæ„ä¹‰ä¸‹çš„å¯†æ–‡ä¿¡æ¯, åˆ†åˆ«è°ƒç”¨p, qå¯ä»¥å¾—åˆ°ä¸åŒæ¨¡genæ„ä¹‰ä¸‹ä¸flagåŠ å¯†æ•°æ®çš„å·®å€¼, å¤šé¡¹å¼çš„sageå‡½æ•°å¯ä»¥å‚è€ƒsakanaè”é˜Ÿçš„ç»´æŠ¤sageæ–‡æ¡£[^sagemath]. æ±‚è§£å¦‚ä¸‹æ‰€ç¤º:

## EXP

```python
from sage.all import *
from Crypto.PublicKey import RSA
from Crypto.Util.number import *
import gmpy2

def find_res(gen):
    R = PolynomialRing(Zmod(gen), 'x')
    x = R.gen()
    f = x ** e - c
    f = f.monic()
    res = f.roots()
    return res

rsa = '''-----BEGIN PUBLIC KEY-----
MIGcMA0GCSqGSIb3DQEBAQUAA4GKADCBhgKBgGjpRi/Hr5oN5NS219dZrq6nW7AC
Y7fUItXAvbgy0TtagVKO2goQiOssL331b7zRjMvdHkEBR4bTd+hHblmynO+2//fz
4DmVgdgMnrP54+2RSzguEGS1ONX4MpJonBsEGGc1IOiKECiwIbl4DkyTxl6AnFsz
ZI2E+lLDZnX5P44FAgEQ
-----END PUBLIC KEY-----
'''

cipher = b'\x10\xc4\xbf\xfapg\xee\x00\xe4\xcd\x00\xb4i\xf5\x801\xdd\xafm\xb1\xad\x8dy\x01\xaa\x14\xd1\xa3\x14[\xdf\xc8c\xb1\xf4\xcb\xcf\xf0\xf9\x83\x85%\x19\xd2d>N\x9aR\xa4\xba\xc9\xda\xd8\xe4\xa2\x9cg%.\xac\xd7\xb5\x95\x7f\x87\x04?\xf7\xe4\x06(\xe7l\x1c"c\x95\x90z\xd4\x8b\x9f\x1b\x00\xc67\xe4\x82g\xc4b\x10\x8c\xe7s[\x95-TB+Z;\xe4\x00\x11<\xc51K\xec\x94ZL\xb2\xf9\x7fp<\xe6C\xf8\x7f\x90\x0bG\xcf'
c = bytes_to_long(cipher)
data = RSA.import_key(rsa)
n = data.n
e = data.e

temp=gmpy2.iroot(n,2)[0]
p = gmpy2.next_prime(temp)
q = n//int(p)
phi = (n-1)*(q-1)

for i in find_res(p):
    for j in find_res(q):
        # ä¸­å›½å‰©ä½™å®šç†
        m =crt([int(i[0]),int(j[0])],[p,q])
        flag = long_to_bytes(m)
        if flag.startswith(b'FMCTF{'):
            print(flag)

# b'FMCTF{S0lv3d_w1th_R4b1n_fx777}'
```

# seal_the_deal

## é¢˜ç›®

```python
from math import gcd
from Crypto.Util.number import getPrime, inverse
from random import randint
import secrets
import time

with open("flag.txt") as f:
    flag = f.readline()

class Paillier:
    def __init__(self, bits):
        self.bits = bits
        self.pub, self.priv = self.keygen()

    def lcm(self, a, b):
        return a * b // gcd(a, b)

    def keygen(self):
        while True:
            p = getPrime(self.bits)
            q = getPrime(self.bits)
            if p != q:
                break
        n = p * q
        Lambda = self.lcm(p - 1, q - 1)  
        g = n + 1  
        mu = inverse(Lambda, n) 
        return ((n, g), (Lambda, mu))

    def encrypt(self, m):
        (n, g) = self.pub
        n_sq = n * n
        while True:
            r = randint(1, n - 1)
            if gcd(r, n) == 1:
                break
        c = (pow(g, m, n_sq) * pow(r, n, n_sq)) % n_sq
        return c

    def decrypt(self, c):
        (n, g) = self.pub
        (Lambda, mu) = self.priv
        n_sq = n * n
        x = pow(c, Lambda, n_sq)  
        m = (((x - 1) // n) * mu) % n  
        return m

    def get_keys(self):
        return self.pub, self.priv

if __name__ == "__main__":

    print("Welcome to the Secure Gate Challenge!")
    paillier = Paillier(256)
    pub, priv = paillier.get_keys()
    print('(n,g)=', pub)
    nums = [secrets.randbits(16) for _ in range(4)]
    res = (nums[0] + nums[1]) + (nums[2] - nums[3])

    ciphers = [paillier.encrypt(i) for i in nums] 
    print('c1 =', ciphers[0])
    print('c2 =', ciphers[1])
    print('c3 =', ciphers[2])
    print('c4 =', ciphers[3])

    try:
        start_time = time.time()
        pass_code = int(input("Can you open the gate? If so, insert the passcode fast: "))
        if time.time() - start_time > 60:  
            print("Too slow! Time's up!")
            exit()
        pass_decode = paillier.decrypt(pass_code)
        if res == pass_decode:
            print(f"Wow! You opened it, The flag is: {flag}")
        else:
            print("Nope, Maybe next time :(")
    except Exception as e:
        print("Invalid input or error occurred:", str(e))
        exit()
```

## åˆ†æ

PaillieråŒæ€åŠ å¯†é—®é¢˜[^paillier], è¿è¡Œé¢˜ç›®å¯ä»¥å¾—çŸ¥éœ€è¦ä½¿ç”¨ç»™å‡ºçš„å››ä¸ªå¯†æ–‡c1ã€c2ã€c3ã€c4è®¡ç®—å‡º$$c1*c2*c3*c4^{-1}\mod {n^2}$$, ç„¶åæŠŠç»“æœä½œä¸ºpass_codeè¾“å…¥, å…¶ä¸­(n, g)æ˜¯å·²çŸ¥çš„, å¯ä»¥ç›´æ¥æå–è®¡ç®—`n_sq = n * n`, æ±‚å‡ºå¯†æ–‡. å€¼å¾—æ³¨æ„çš„æ˜¯é‡Œé¢è¿›è¡Œäº†æ—¶é—´é™åˆ¶, æ¨èä½¿ç”¨pwntoolsç›´æ¥äº¤äº’.

## EXP

```python
from pwn import *
import re

#r = remote('seal-the-deal.fmc.tf',2003)
r = process(['python', 'server.py'])

r.recvline()
pub_line = r.recvline().decode().strip()
n, g = map(int, re.findall(r'\d+', pub_line))

ciphers = []
for _ in range(4):
    line = r.recvline().decode().strip()
    c = int(line.split(' = ')[1])
    ciphers.append(c)

c1, c2, c3, c4 = ciphers
n_sq = n * n

product = (c1 * c2) % n_sq
product = (product * c3) % n_sq

inv_c4 = pow(c4, -1, n_sq)
pass_code = (product * inv_c4) % n_sq
r.sendline(str(pass_code).encode())

print(r.recvall())

# b'Can you open the gate? If so, insert the passcode fast: Wow! You opened it, The flag is: FMCTF{P41ll13r_h0m0m0rph1c_3n4bl35_c0mpu7at10n_0n_c1ph3r5}'
```

# superguesser

## é¢˜ç›®

```python
#!/usr/local/bin/python

import random
import time
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

MAX_ATTEMPTS = 1000

def encrypt_flag(flag):
    key = random.getrandbits(128).to_bytes(16, 'big')
    iv = random.getrandbits(128).to_bytes(16, 'big')
    cipher = AES.new(key, AES.MODE_CBC, iv)
    encrypted = cipher.encrypt(pad(flag.encode(), AES.block_size))
    return encrypted

def main():
    random.seed(time.time())
    encrypted_flag = encrypt_flag(open('./flag.txt').read())
    print("\nâœ¨ Welcome to the **Guess the Number Challenge v1**! âœ¨")
    print("ğŸ•µï¸â€â™‚ï¸ Can you uncover the secret behind the encrypted flag?")
    print("ğŸ“œ Use your intelligence, strategy, and the hints provided to succeed!")

    print("Your task: Use your wits and strategy to uncover hints to decrypt the flag.")
    print(f"\nHere is your encrypted flag: \n{encrypted_flag.hex()}")
    print("\nBut don't worry, I'm generous. I've precomputed 1000 random hints for you!")
    print(f"You have {MAX_ATTEMPTS} attempts to guess the right index.\n")
    hints = [random.getrandbits(32) for _ in range(1000)]
    for attempt in range(1, MAX_ATTEMPTS + 1):
        print(f"Attempt {attempt}/{MAX_ATTEMPTS}")
        try:
            index = int(input("Enter an index (0-999): ").strip())
            if 0 <= index < 1000:
                print(f"ğŸ”‘ Hint at index {index}: {hints[index]}")
            else:
                print("âŒ Invalid index! Please enter a number between 0 and 999.\n")
        except ValueError:
            print("âŒ Invalid input! Please enter a valid integer.\n")
    print("\nâœ¨ Your attempts are over! But don't give up just yet.")
    print("âœ¨ Your attempts are over! Good luck solving the challenge!\n")
    print("ğŸ” Don't forget: The key to solving the challenge lies in these random hints. Goodbye!")

if __name__ == "__main__":
    main()
```

## åˆ†æ

è¿™ä¸¤é¢˜å·®ä¸å¤š, å¯ä»¥ç›´æ¥å‚è€ƒä¸‹é¢.

# superguesser_v2

## é¢˜ç›®

```python
#!/usr/local/bin/python

import os
import random
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

MAX_ATTEMPTS = 10

def encrypt_flag(flag, iv):
    key = random.getrandbits(128).to_bytes(16, 'big')
    cipher = AES.new(key, AES.MODE_CBC, iv*2)
    encrypted = cipher.encrypt(pad(flag.encode(), AES.block_size))
    return encrypted

def main():
    secureSeed = os.urandom(8)
    random.seed(secureSeed)
    hints = [random.getrandbits(32) for _ in range(624)]
    encrypted_flag = encrypt_flag(open('./flag.txt').read(), secureSeed)

    print("\nâœ¨ Welcome to the **Guess the Number Challenge v2**! âœ¨")
    print("ğŸ•µï¸â€â™‚ï¸ Your mission: Decode the encrypted flag by uncovering critical hints.")
    print("ğŸ“Š We've precomputed 624 random numbers using a secure PRNG.")
    print(f"â— But there's a catch: You can only access {MAX_ATTEMPTS} of them.")
    print("ğŸ”‘ Choose your indices wisely to uncover the key!")
    print("\nğŸ“œ Instructions:")
    print("1ï¸âƒ£ You have 624 unique random numbers that are critical for decrypting the flag.")
    print("2ï¸âƒ£ Enter an index (0-623) to reveal a hint.")
    print(f"3ï¸âƒ£ You only have {MAX_ATTEMPTS} attempts, so choose wisely!")
    print("4ï¸âƒ£ Use your understanding of randomness to crack the secure seed.")

    print(f"\nğŸ”’ Here is your encrypted flag: \n{encrypted_flag.hex()}")
    print(f"\nGood luck! You have {MAX_ATTEMPTS} attempts to guess the correct index.\n")

    for attempt in range(1, MAX_ATTEMPTS + 1):
        print(f"Attempt {attempt}/{MAX_ATTEMPTS}")
        try:
            index = int(input("Enter an index (0-624): ").strip())
            if 0 <= index < 624:
                print(f"Hint at index {index}: {hints[index]}\n")
            else:
                print("âŒ Invalid index! Please enter a number between 0 and 624.\n")
        except ValueError:
            print("âŒ Invalid input! Please enter a valid integer.\n")
    print("âœ¨ Your attempts are over! Good luck solving the challenge!\n")
    print("ğŸ” Remember, the flag is encrypted. Use your hints wisely. Goodbye!")

if __name__ == "__main__":
    main()
```

## åˆ†æ

å¯ä»¥ä½¿ç”¨[randomåº“POCè„šæœ¬](https://github.com/StackeredSAS/python-random-playground/blob/main/recover_BytesV2Seed.py)è¿›è¡Œæ”»å‡»,[^prng], æœ‰ç‚¹éº»çƒ¦, åˆšå¥½æœ€è¿‘å¿™, æœ‰æ—¶é—´å•ç‹¬å¼€ä¸€ä¸ªåšå®¢å†™.

# å‚è€ƒæ–‡çŒ®


[^sagemath]: sakana_ctf.æ¬¢è¿æ¥åˆ°Sageç¤¾åŒº[EB/OL].gitee.<a target="_blank" href='https://gitee.com/sakana_ctf/sagemath/blob/master/sakana/polynomial/basic.md'>https://gitee.com/sakana_ctf/sagemath/blob/master/sakana/polynomial/basic.md</a>.2023-11-22
[^paillier]: joey.åº”ç”¨å¯†ç å­¦ | PaillieråŒæ€åŠ å¯†ç®—æ³•ç®€ä»‹[EB/OL].gitee.<a target="_blank" href='https://zhuanlan.zhihu.com/p/557034854'>https://zhuanlan.zhihu.com/p/557034854</a>.2023-08-29
[^prng]: StackeredSAS.Python random playground[EB/OL].github.<a target="_blank" href='https://github.com/StackeredSAS/python-random-playground'>https://github.com/StackeredSAS/python-random-playground</a>.2024-04-16




